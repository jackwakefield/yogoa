// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Sun, 28 Oct 2018 20:23:31 GMT.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package yoga

/*
#cgo CFLAGS: -I../yoga
#cgo CXXFLAGS: -std=c++14 -g
#cgo LDFLAGS: -lm
#include "Yoga.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocSizeMemory allocates memory for type C.YGSize in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSizeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSizeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSizeValue = unsafe.Sizeof([1]C.YGSize{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Size) Ref() *C.YGSize {
	if x == nil {
		return nil
	}
	return x.ref626288d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Size) Free() {
	if x != nil && x.allocs626288d != nil {
		x.allocs626288d.(*cgoAllocMap).Free()
		x.ref626288d = nil
	}
}

// NewSizeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSizeRef(ref unsafe.Pointer) *Size {
	if ref == nil {
		return nil
	}
	obj := new(Size)
	obj.ref626288d = (*C.YGSize)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Size) PassRef() (*C.YGSize, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref626288d != nil {
		return x.ref626288d, nil
	}
	mem626288d := allocSizeMemory(1)
	ref626288d := (*C.YGSize)(mem626288d)
	allocs626288d := new(cgoAllocMap)
	allocs626288d.Add(mem626288d)

	var cwidth_allocs *cgoAllocMap
	ref626288d.width, cwidth_allocs = (C.float)(x.Width), cgoAllocsUnknown
	allocs626288d.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref626288d.height, cheight_allocs = (C.float)(x.Height), cgoAllocsUnknown
	allocs626288d.Borrow(cheight_allocs)

	x.ref626288d = ref626288d
	x.allocs626288d = allocs626288d
	return ref626288d, allocs626288d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Size) PassValue() (C.YGSize, *cgoAllocMap) {
	if x.ref626288d != nil {
		return *x.ref626288d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Size) Deref() {
	if x.ref626288d == nil {
		return
	}
	x.Width = (float32)(x.ref626288d.width)
	x.Height = (float32)(x.ref626288d.height)
}

// allocValueMemory allocates memory for type C.YGValue in C.
// The caller is responsible for freeing the this memory via C.free.
func allocValueMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfValueValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfValueValue = unsafe.Sizeof([1]C.YGValue{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Value) Ref() *C.YGValue {
	if x == nil {
		return nil
	}
	return x.ref23e8c9e3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Value) Free() {
	if x != nil && x.allocs23e8c9e3 != nil {
		x.allocs23e8c9e3.(*cgoAllocMap).Free()
		x.ref23e8c9e3 = nil
	}
}

// NewValueRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewValueRef(ref unsafe.Pointer) *Value {
	if ref == nil {
		return nil
	}
	obj := new(Value)
	obj.ref23e8c9e3 = (*C.YGValue)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Value) PassRef() (*C.YGValue, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref23e8c9e3 != nil {
		return x.ref23e8c9e3, nil
	}
	mem23e8c9e3 := allocValueMemory(1)
	ref23e8c9e3 := (*C.YGValue)(mem23e8c9e3)
	allocs23e8c9e3 := new(cgoAllocMap)
	allocs23e8c9e3.Add(mem23e8c9e3)

	var cvalue_allocs *cgoAllocMap
	ref23e8c9e3.value, cvalue_allocs = (C.float)(x.Value), cgoAllocsUnknown
	allocs23e8c9e3.Borrow(cvalue_allocs)

	var cunit_allocs *cgoAllocMap
	ref23e8c9e3.unit, cunit_allocs = (C.YGUnit)(x.Unit), cgoAllocsUnknown
	allocs23e8c9e3.Borrow(cunit_allocs)

	x.ref23e8c9e3 = ref23e8c9e3
	x.allocs23e8c9e3 = allocs23e8c9e3
	return ref23e8c9e3, allocs23e8c9e3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Value) PassValue() (C.YGValue, *cgoAllocMap) {
	if x.ref23e8c9e3 != nil {
		return *x.ref23e8c9e3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Value) Deref() {
	if x.ref23e8c9e3 == nil {
		return
	}
	x.Value = (float32)(x.ref23e8c9e3.value)
	x.Unit = (Unit)(x.ref23e8c9e3.unit)
}

func (x MeasureFunc) PassRef() (ref *C.YGMeasureFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if measureFuncECADCDC6Func == nil {
		measureFuncECADCDC6Func = x
	}
	return (*C.YGMeasureFunc)(C.YGMeasureFunc_ecadcdc6), nil
}

func (x MeasureFunc) PassValue() (ref C.YGMeasureFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if measureFuncECADCDC6Func == nil {
		measureFuncECADCDC6Func = x
	}
	return (C.YGMeasureFunc)(C.YGMeasureFunc_ecadcdc6), nil
}

func NewMeasureFuncRef(ref unsafe.Pointer) *MeasureFunc {
	return (*MeasureFunc)(ref)
}

//export measureFuncECADCDC6
func measureFuncECADCDC6(cnode C.YGNodeRef, cwidth C.float, cwidthMode C.YGMeasureMode, cheight C.float, cheightMode C.YGMeasureMode) C.YGSize {
	if measureFuncECADCDC6Func != nil {
		nodeecadcdc6 := *(*NodeRef)(unsafe.Pointer(&cnode))
		widthecadcdc6 := (float32)(cwidth)
		widthModeecadcdc6 := (MeasureMode)(cwidthMode)
		heightecadcdc6 := (float32)(cheight)
		heightModeecadcdc6 := (MeasureMode)(cheightMode)
		retecadcdc6 := measureFuncECADCDC6Func(nodeecadcdc6, widthecadcdc6, widthModeecadcdc6, heightecadcdc6, heightModeecadcdc6)
		ret, _ := retecadcdc6.PassValue()
		return ret
	}
	panic("callback func has not been set (race?)")
}

var measureFuncECADCDC6Func MeasureFunc

func (x BaselineFunc) PassRef() (ref *C.YGBaselineFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if baselineFuncE756B14AFunc == nil {
		baselineFuncE756B14AFunc = x
	}
	return (*C.YGBaselineFunc)(C.YGBaselineFunc_e756b14a), nil
}

func (x BaselineFunc) PassValue() (ref C.YGBaselineFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if baselineFuncE756B14AFunc == nil {
		baselineFuncE756B14AFunc = x
	}
	return (C.YGBaselineFunc)(C.YGBaselineFunc_e756b14a), nil
}

func NewBaselineFuncRef(ref unsafe.Pointer) *BaselineFunc {
	return (*BaselineFunc)(ref)
}

//export baselineFuncE756B14A
func baselineFuncE756B14A(cnode C.YGNodeRef, cwidth C.float, cheight C.float) C.float {
	if baselineFuncE756B14AFunc != nil {
		nodee756b14a := *(*NodeRef)(unsafe.Pointer(&cnode))
		widthe756b14a := (float32)(cwidth)
		heighte756b14a := (float32)(cheight)
		rete756b14a := baselineFuncE756B14AFunc(nodee756b14a, widthe756b14a, heighte756b14a)
		ret, _ := (C.float)(rete756b14a), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var baselineFuncE756B14AFunc BaselineFunc

func (x DirtiedFunc) PassRef() (ref *C.YGDirtiedFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if dirtiedFunc91998949Func == nil {
		dirtiedFunc91998949Func = x
	}
	return (*C.YGDirtiedFunc)(C.YGDirtiedFunc_91998949), nil
}

func (x DirtiedFunc) PassValue() (ref C.YGDirtiedFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if dirtiedFunc91998949Func == nil {
		dirtiedFunc91998949Func = x
	}
	return (C.YGDirtiedFunc)(C.YGDirtiedFunc_91998949), nil
}

func NewDirtiedFuncRef(ref unsafe.Pointer) *DirtiedFunc {
	return (*DirtiedFunc)(ref)
}

//export dirtiedFunc91998949
func dirtiedFunc91998949(cnode C.YGNodeRef) {
	if dirtiedFunc91998949Func != nil {
		node91998949 := *(*NodeRef)(unsafe.Pointer(&cnode))
		dirtiedFunc91998949Func(node91998949)
		return
	}
	panic("callback func has not been set (race?)")
}

var dirtiedFunc91998949Func DirtiedFunc

func (x PrintFunc) PassRef() (ref *C.YGPrintFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if printFunc6B37638DFunc == nil {
		printFunc6B37638DFunc = x
	}
	return (*C.YGPrintFunc)(C.YGPrintFunc_6b37638d), nil
}

func (x PrintFunc) PassValue() (ref C.YGPrintFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if printFunc6B37638DFunc == nil {
		printFunc6B37638DFunc = x
	}
	return (C.YGPrintFunc)(C.YGPrintFunc_6b37638d), nil
}

func NewPrintFuncRef(ref unsafe.Pointer) *PrintFunc {
	return (*PrintFunc)(ref)
}

//export printFunc6B37638D
func printFunc6B37638D(cnode C.YGNodeRef) {
	if printFunc6B37638DFunc != nil {
		node6b37638d := *(*NodeRef)(unsafe.Pointer(&cnode))
		printFunc6B37638DFunc(node6b37638d)
		return
	}
	panic("callback func has not been set (race?)")
}

var printFunc6B37638DFunc PrintFunc

func (x CloneNodeFunc) PassRef() (ref *C.YGCloneNodeFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if cloneNodeFunc7C7B6182Func == nil {
		cloneNodeFunc7C7B6182Func = x
	}
	return (*C.YGCloneNodeFunc)(C.YGCloneNodeFunc_7c7b6182), nil
}

func (x CloneNodeFunc) PassValue() (ref C.YGCloneNodeFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if cloneNodeFunc7C7B6182Func == nil {
		cloneNodeFunc7C7B6182Func = x
	}
	return (C.YGCloneNodeFunc)(C.YGCloneNodeFunc_7c7b6182), nil
}

func NewCloneNodeFuncRef(ref unsafe.Pointer) *CloneNodeFunc {
	return (*CloneNodeFunc)(ref)
}

//export cloneNodeFunc7C7B6182
func cloneNodeFunc7C7B6182(cconfig C.YGConfigRef, coldNode C.YGNodeRef, cowner C.YGNodeRef, cchildIndex C.int) C.YGNodeRef {
	if cloneNodeFunc7C7B6182Func != nil {
		config7c7b6182 := *(*ConfigRef)(unsafe.Pointer(&cconfig))
		oldNode7c7b6182 := *(*NodeRef)(unsafe.Pointer(&coldNode))
		owner7c7b6182 := *(*NodeRef)(unsafe.Pointer(&cowner))
		childIndex7c7b6182 := (int32)(cchildIndex)
		ret7c7b6182 := cloneNodeFunc7C7B6182Func(config7c7b6182, oldNode7c7b6182, owner7c7b6182, childIndex7c7b6182)
		ret, _ := *(*C.YGNodeRef)(unsafe.Pointer(&ret7c7b6182)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var cloneNodeFunc7C7B6182Func CloneNodeFunc

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}
